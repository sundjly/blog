
ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。

<!--more-->

[转自阮一峰的Javascript 严格模式详解](http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html) 
 
### 关于应用

1. 针对整个脚本文件 
将”use strict”放在脚本文件的第一行，则整个脚本都将以”严格模式”运行 
列入：

```
<script>
　　　　"use strict";
　　　　console.log("这是严格模式。");
</script>
```

2. 针对单个函数 
将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行。 

```
function strict(){ 
　　　　“use strict”; 
　　　　return “这是严格模式。”; 
　　}
```

3. 脚本文件的变通写法 
因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。 

```
(function (){

　　　　“use strict”; 
　　　　// some code here

　　 })();
```


### 语法和行为改变 
###### 2.1 全局变量显式声明 

严格模式下，变量都必须先用var命令声明，然后再使用。

###### 2.2“静态绑定“ 

Javascript语言的一个特点，就是允许”动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。 

严格模式对动态绑定做了一些限制。属性和方法到底归属哪个对象，在编译阶段就确定。

（要注意：strict mode和绑定无关，JS始终是动态绑定的语言。下面两点也只是把以前随意扩大的scope收缩一下而已） 

（1）禁止使用with语句 

```
“use strict”; 
　　var v = 1; 
　　with (o){ // 语法错误 
　　　　v = 2; 
　　} 
//因为with语句无法在编译时就确定，属性到底归属哪个对象。
```

（2）创设eval作用域 

正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。

严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。 

```
“use strict”; 
　　var x = 2; 
　　console.info(eval(“var x = 5; x”)); // 5 
　　console.info(x); // 2
```


###### 2.3 增强的安全措施 

（1）禁止this关键字指向全局对象 

（2）禁止在函数内部遍历调用栈 

###### 2.4 禁止删除变量 

严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。 

###### 2.5 显式报错 

- 正常模式下，对一个对象的 **只读属性**进行赋值，不会报错，只会默默地失败。严格模式下，将报错。 
- 对一个使用get()方法读取的属性进行赋值，会报错 
- 对禁止扩展的对象添加新属性，会报错。 
- 删除一个不可删除的属性，会报错。

###### 2.6 重名错误 

（1）对象不能有重名的属性 

（2）函数不能有重名的参数 

正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。

###### 2.7 禁止八进制表示法 

正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。 
###### 2.8 arguments对象的限制 

（1）不允许对arguments赋值 

（2）arguments不再追踪参数的变化 

（3）禁止使用arguments.callee

这意味着，你无法在匿名函数内部调用自身了。 

###### 2.9 函数必须声明在顶层 不允许在非函数的代码块内声明函数。 

###### 2.10 保留字 为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。